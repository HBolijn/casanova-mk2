In this section we sum up the content of this work, with particular focus on: \textit{(i)} how Casanova answers the original questions of this thesis; \textit{(ii)} what are the limitations of Casanova that may be solved with small extensions; \textit{(iii)} what are the limitations of Casanova that may be solved with a major design effort or not at all.

\section{Original research questions}
The research questions studied by this work are listed in Chapter \ref{chap:introduction}, but we sum them up here again:

\input{Chapters/research_questions}

We have identified a set of requirements by observing which are the most common tasks performed by game developers while making a game. These are tasks that allow the simulation of a virtual world that is updated in real-time, steered by the user input, while providing a real-time visual representation of the virtual world. We have identified these requirements through our experience with game development, by studying the architectures of multiple game development tools and libraries, and by a survey of the fundamental literature of game development which all mentions these constructs. Even though we believe to have identified a set of universal, core requirements of games, we are also certain that further important requirements exist that we are not considering. We also believe that the requirements we consider here are the first that should be tackled, since considering more exotic issues would require that these are solved first.

A preliminar study of the available game development systems yielded dozens of powerful systems, engines, and frameworks, plus various languages. As game development is a complex activity, so game development tools are large and difficult to learn. To narrow our focus we started by restricting ourselves to only those tools that are aimed at making the same kind of games that Casanova supports, namely serious, research, and indie games. Secondly, we picked the three systems that seem the most popular in terms of available books, tutorials, documentation, and sample projects.
Choosing game development languages on the other hand was simpler, since there are not many available. We picked three languages that exemplified that language design does not need to be a derivative effort that yields yet another imperative language with objects; we picked languages that show provocative new semantic and syntactic structures.

We designed Casanova around the identified requirements for games, by choosing the design philosophy of less-is-more. We tried to find the smallest set of orthogonal syntactic primitives that would allow the expression of the desired semantics. We built Casanova semantics in order to express game concepts of input, drawing, time flow, state machines, and few other primitives. We used our type system to support useful correctness enforcers such as dimensional analysis. We built an implementation that optimizes run-time by taking advantage of the semantics of the game, for example by adding multi-threading automatically where it is safe to do so.

We evaluated Casanova by showing how actual game snippets can be produced in it, and by identifying exemplar game development tasks such as defining an avatar, interacting and moving in a virtual environment with entities representing objects and monsters, and so on. We then proceeded to a comparison of Casanova with existing game development systems in order to assess complexity. We also offered some benchmarks that quantified certain indicators of performance and verbosity. These benchmarks compare coroutine systems across multiple scripting languages commonly used in games, in order to assess how well Casanova stacks against them in one of its most complex (and computationally intensive) sub-systems. Finally, we performed some user studies with students ranging from complete beginners in Computer Science, to advanced programmers learning the finer points of game development.

\section{Extension opportunities for Casanova}
% todo: add various references in the following

\subsection{Rendering}
Rendering in Casanova is the weakest aspect of the current implementation and design. On one hand we believe that rendering is almost not an open problem anymore, and that much of the current research on rendering is actually focused on technical, engineering, and approximation efforts [] rather than on fundamental understanding of photo-realistic lighting models []. Since we aim at solving fundamental issues with game development in general, we have chosen to create a first rendering system that allows testing of the rest of Casanova, with the objective to integrate some other rendering engine, possibly even Unity itself (or any other engine that supports .Net/Mono bindings), when the framework is sufficiently mature that the current drawing facilities become inadequate.

\subsection{Standard library}
Casanova also lacks a standard library. A standard library for a system such as Casanova would provide sets of entities that cooperate with each other in order to provide some pervasive game functionality like physics, or even whole game skeletons for different genres. Such a library would allow us to inject past experience in making certain games into Casanova, thereby further reducing the difficulty of game development with the framework; unfortunately, building such a library requires a substantial engineering effort, and is partially beyond the current scope of this work. Still, we are slowly increasing the size of the Casanova library of utilities by generalizing the various portions of the games we build when we see components that may be of broader utility.

\subsection{IDE}
The current IDE for Casanova is also a major source of future work. On one hand the implementation is lacking all the code-completion technologies that many programmers are used to, and which make coding much simpler as it allows to keep track of the source code structure automatically. Code completion also helps greatly when getting confidence with new and unknown libraries, since it makes it possible to interactively explore them without reading lots of documentation before hand. 
Also, the IDE's compiler would be the ideal candidate to start supporting the actual grammar of Casanova and to generate the final F\# code which currently has to be written by hand. 
% todo: clarify
This would remove the need for some small syntactic improvements that are currently not possible in F\#, but it would also enable more complex code transformations such as optimizations of queries and similar improvements that are currently confined to the design of Casanova and not part of the implementation.

% todo: expand, and better divide problem of FSM representation and solution
Further extensions that a proper language could support include the generation of faster, low-level state machines from coroutines, thereby reducing the amount of garbage that is currently produced as a side effect of allocation the continuation of coroutines with the application of the monadic binding operator. The result would be less performance spent on garbage collection of Casanova programs, a small improvement on PCs where the garbage collector is highly optimized, but a potentially bigger advantage on platforms such as the XBox or tablet PCs where garbage collection often uses slower implementations [].

\subsection{Networking}
% todo: split the concerns of networking and those of AI
% todo: swap and split problems and solution
Finally, there are two big extensions that could be added to Casanova: networking and AI. These two are being studied and already have a prototype implementation, as described in Appendix \ref{chap:networking} and Appendix \ref{chap:goap}.
Networking is relatively simpler to implement, since there is a limited set of heuristics that can be employed that are aimed at reducing the bandwidth needed by the game (not transfering what does not change [], or computing locally what can be computed []), or at reducing the perception of delays in synchronization (by anticipating locally []).

\subsection{AI}
AI is more complex to build, since there are no true general-purpose frameworks for game AI. Most AI is tailor-made around a specific game, often employing ad-hoc techniques that have little relationship to the research results in the field of AI []. This is due to the fact that AI in games must be very high performance, must be adjustable to the desired level of difficulty, and needs to look convincing []; these goals, especially the first, are rarely a central consideration for "classical AI" researchers. We are studying an adaptation of the GOAP algorithm [] that could offer high performance, while being general purpose and adaptable to a large variety of games. Our current results are detailed in Appendix \ref{chap:goap}.

\section{Shortcomings of Casanova}
Casanova also has some shortcomings which determine what games it cannot be used to build. The main shortcomings that we have identified are: \textit{(i)} the inability to do low-level optimizations; \textit{(ii)} the required mindset shift for imperative programmers; \textit{(iii)} the rarely-seen ML syntax; and \textit{(iv)} the difficulty of expressing complex rendering tasks such as shaders.

\subsection{Low-level optimizations}
Most games, especially (but not limited to) larger titles, are sometimes faced with a need for optimization at a very low level, for example in order to run on less powerful hardware such as tablets or smartphones, or to support complex scenarios that require making use of all the available computational power.

Low-level optimizations may include control over memory allocations and deallocations, doubly-linked lists to quickly move an object from one group to another, and even re-writing some central portions of the inner loop in assembly []. Unfortunately, these optimizations come at a cost: very little can be said (or controlled) about such portions of code, which would possibly break all the other semantic structures of the language. We argue that supporting low-level optimizations should be done only if we can at the same time retain all the properties of the system. Alternatively, we believe that better automated optimizations could further remove the need or desire to perform such optimizations.

\subsection{Imperative mindset shift}
Casanova is a hybrid language that uses declarative/functional primitives for a large part of the game (namely, rules). The fact that rules may not affect any entity excluded the one they are operating on may cause some difficulties in programmers used to imperative operations that allow them to potentially modify any entity in the program from virtually any place in the code. This form of programming though may encounter difficulties in scaling with larger projects, since complex side-effects may get out of hand and break invariants that are otherwise assumed []. Learning a declarative/functional way of thinking about programs can be a valuable skill in that it allows to cleanly split functionality in such a way that testing is easier (testing a rule can be done in isolation and there are no unforeseen side-effects that may invalidate the tests) [], and also that reasoning on the program is easier as well []. 
This said, programmers coming from an imperative background may require a larger initial effort than people with no background in programming at all, as we have discussed in Chapter [].

\subsection{Unusual syntax}
Similarly to the issues with the declarative/functional style of programming, the syntax of Casanova is based on the lesser known syntax of ML and F\#. This syntax is widely used nowadays, but not as much as that of other imperative languages such as C, Java, C\#, or Python.
Building an alternate syntactic front-end would not change the underlying semantics or possibly even the backend implementation of our system, but it would still require substantial work in both design and implementation. Using a more common syntax, though, may reduce the perceived steepness of the learning curve of Casanova and thus remains a desirable feature.

\subsection{Advanced rendering}
% todo: may be expanded and detailed, possibly even in an appendix

Programming complex rendering operations is, as of now, delegated to the underlying rendering mechanisms of the graphics engine used by Casanova. We argue that it would be desirable to be able to express complex rendering operations in Casanova itself, for example by defining shaders, render target, etc. with separate syntactic abstractions. Unfortunately this would require a major design and implementation effort, and as such it must be relegated to our future intentions.
