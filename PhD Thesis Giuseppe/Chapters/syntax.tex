In this chapter we give the syntax of the Casanova language. The syntax of the language is an abstract definition of all the valid strings that are part of the language. The most common tool to give the syntax of a language is, of course, a formal grammar. Since Casanova is a statically typed language, the grammar is insufficient to capture all the valid programs. Some programs for which typing is incorrect would be accepted by the grammar, but would not be valid Casanova programs. For example, consider the following simple expression:

\begin{lstlisting}
if a < b then 0 else "zero"
\end{lstlisting}

The expression above can be generated by the grammar of Casanova, but it would be rejected by its type system since it is not possible to unify the types \texttt{int} and \texttt{string} of the two branches. To give the full syntax of Casanova we must also know the typing rules, which in fact we give together with the grammar.

\section{Grammar}
The grammar of Casanova states that a valid program starts with a series of mutually recursive \textit{type definitions}; mutual recursion means that the definition of a type may use any other type defined in the program, regardless of the fact that the referenced type definition happens after the definition of the current type. 

Type definitions also contain \textit{rules}, which are special methods that cannot be used by the developer explicitly, but only by the framework; rules are associated with exactly one attribute, and one attribute may be associated to at most one rule. Rules define declaratively what the value for an attribute will be at the next iteration of the game loop, and a rule can access the previous values of the game world and the entity of which it is performing a partial update. Rules cannot have side-effects beyond their implicit one, that is a rule is not allowed to write variables or modify anything. Its only side-effect comes from the fact that its result will become part of the game world at the next iteration of the game loop. 

The program then contains a definition of the \textit{initial value} of the game world. 

Finally, the program must have a \textit{main script} that defines the process that will handle the high-level game logic, plus a series of \textit{input scripts}. All scripts are defined through coroutines.

The grammar that describes the syntax of a Casanova program then is:

\begin{lstlisting}[texcl]
<p>          ::= <type-decls> <initial-world> <scripts>
<type-decls> ::= <type-decl> | <type-decl> <type-decls>
<type-decl>  ::= `type' <id> `=' <type-body>
<type-body>  ::= <record-body> | <union-body>

<record-body> ::= `{' <labels> `}' <rules>
<labels>      ::= <label> | <label>`;' <labels>
<label>       ::= <id> `:' <type-expr>

<type-expr>           ::= <id> | <tuple-type-expr> 
                        | <intrinsic-type-expr>
<tuple-type-expr>     ::= <type-expr> 
                        | <type-expr> `*' <tuple-type-expr>
<intrinsic-type-expr> ::= `Var<'<type-expr>`>' 
                        | `Ref<'<type-expr>`>' 
                        | `List<'<type-expr>`>' 
                        | `Coroutine<'<type-expr>`>' 
                        | float | int | Vector2 | ...
<rules>               ::= empty | <rule> <rules>
<rule>                ::= `rule' <rule-id> `=' <expr>
<rule-id>             ::= <id> | <id>`.'<rule-id>
<union-body>          ::= <id> | <id> `of' <type-expr> 
                        | <id> `|' <union-body> 
                        | <id> `of' <type-expr> `|' <union-body>

<type-init>           ::= <tuple-init> | <list-init> 
                        | <record-init> | <union-init> 
                        | <intrinsic-type-init>
<tuple-init>          ::= <expr> | <expr>, <tuple-init>
<list-init>           ::= `[' <expr-list> `]' | `[' <list-compr> `]'
<list-compr>          ::= `for' <id> `in' <expr> `do' <expr>
<expr-list>           ::= `' | <expr> `;' <expr-list>
<record-init>         ::= `{' <labels-init> `}'
<labels-init>         ::= <id> `=' <expr> | <id> `=' <expr> `;' <labels-init>
<union-init>          ::= <id> | <id> <tuple-init>
<intrinsic-type-init> ::= `ref' <expr> | `var' <expr> 
                        | `Vector2(' <expr> `,' <expr> `)' | ...
<type-dest>           ::= `let' <ids> `=' <expr> | <match-case> 
                        | <match-list> | <id> `.' <id>
<ids>                 ::= <id> | <id> `,' <ids>
<match-case>          ::= `match' <expr> `with' <patterns>
<patterns>            ::= <pattern> | <pattern> `|' <patterns>
<pattern>             ::= <id> | <ids> | <id> `(' <pattern-args> `)'
<pattern-args>        ::= <pattern-arg> | <pattern-arg> `,' <pattern-args>
<pattern-arg>         ::= <id> | <const>
<match-list>          ::= `[]' | <id> `::' <id>

<id-decl> ::= <id> | <id> `:' <type-expr>
<expr>    ::= <id> | <const> 
            | `let' <id> `=' <expr> `in' <expr> 
            | `if' <expr> `then' <expr> `else' <expr> 
            | <type-init> | <type-dest> 
            | <co-expr> | ...
<co-expr> ::= `co{' <co-expr> `}' | <expr> | `return' <expr> 
            | `let!' <id> `=' <expr> `in' <expr> 
            | `do!' <expr> `;' <expr> 
            | <expr> `||' <expr> | <expr> `&&' <expr> 
            | <expr> `=>' <expr> | `repeat' <expr> 
            | `yield'
<id>      ::= ... (* an alphanumeric string *)
<const>   ::= ... (* a constant value *)

<initial-world> ::= `let world =' <expr>
<scripts>       ::= <main-script> <input-script> 
<main-script>   ::= `let main =' <expr>
<input-script>  ::= `let input =' <expr>
\end{lstlisting}

We have omitted some of the grammatical structures which are best known from the literature (see, for one example, \cite{CHAPTER_1_PL_INFLUENCE_ON_PL}): \textit{(i)} the full list of supported intrinsic types (strings, matrices, 3D and 4D vectors, etc.); \textit{(ii)} the initialization syntax for the intrinsic types; and \textit{(iii)} expressions may assume a very large number of shapes, from arithmetic operations such as \textit{expr + expr}, to function calls, function definitions, library functions such as \texttt{List.length}, etc.

\section{Type System}
The type system for Casanova contains the standard functional type system of F\#; this means that we have the usual rules such as:

\begin{mathpar}

\inferrule
{\Gamma \vdash t_1:\texttt{U,}\ \Gamma,x:\texttt{U} \vdash t_2:\texttt{V}}
{\Gamma \vdash \texttt{let }x \texttt{=} t_1 \texttt{ in } t_2:V}

\inferrule
{\Gamma \vdash cond:\texttt{bool}, t_1:\texttt{U}, t_2:\texttt{U}}
{\Gamma \vdash \texttt{if }cond\texttt{ then }t_1\texttt{ else } t_2:U}

\inferrule
{\Gamma \vdash f:U \rightarrow V, t:U}
{\Gamma \vdash f t:V}

\inferrule
{\Gamma \vdash t:\{l_1:T_1;l_2:T_2;...l_n:T_n\}}
{\Gamma \vdash t.l_i:T_i}
\end{mathpar}

and so on. For a complete treatment of the rules of a programming language with this kind of this type system, there are many excellent sources such as \cite{CHAPTER_1_PL_INFLUENCE_ON_PL}.

The most unusual and novel aspects of Casanova's type system are two: rules, and coroutines. We are now going to explain them in detail. 

\subsection{Rules}
Rules are functions that take as input the game world, the current entity the rule belongs to, and the delta time since the last evaluation of this rule; the rule type has range equal to the type identified by its name, treated as a record label. A rule is well-defined if the following holds for all rules:

\begin{lstlisting}
type ID = { l1:T1; l2:T2; ... ln:Tn } 
  rule li = (ei:World * ID * float<s> -> Ti)
\end{lstlisting}

For example we could write:

\begin{lstlisting}
type Ball = { P:Vector2<m>; V:Vector2<m/s> } 
  rule P(world:World,self:Ball,dt:float<s>) =
    self.P + self.V * dt
\end{lstlisting}

We could also write the very same definition where the method body is defined as a function value as:

\begin{lstlisting}
type Ball = { P:Vector2<m>; V:Vector2<m/s> } 
  rule P = fun (world:World,self:Ball,dt:float<s>) ->
    self.P + self.V * dt
\end{lstlisting}

Rules may also refer to the fields inside the value of an attribute. For example, a rule may define how attribute \texttt{kj} of attribute \texttt{li} is updated as in the following:

\begin{lstlisting}
type ID = { l1:T1; ...; li:{k1:V1; k2:V2; ... km:Vm} ln:Tn } 
  rule li.kj = (eij:World * ID * float<s> -> Vj)
\end{lstlisting}

For example we could only update the \texttt{Y} field of the ball position as:

\begin{lstlisting}
type Ball = { P:Vector2<m>; VelY:float<m/s> } 
  rule P.Y(world:World,self:Ball,dt:float<s>) =
    self.P.Y + self.VelY * dt
\end{lstlisting}


Longer chains are handled in a similar fashion.

\subsection{Coroutines}
The second novel aspect of Casanova is that it uses a rare \footnote{rare in applied work on programming languages as compared to theoretical research} feature of type systems that assigns a type to mutable computations. Mutable computations are all those statements that have side-effects such as modifying the memory through an assignment, sending data across the network, drawing to the screen, etc. For this reason mutable computations are also referred to as \textit{effectful}. For example, in a traditional imperative language such as C, Java or others, assigning a variable is just a statement with type \texttt{void}. The same holds true for F\# as well, which types these effectful computations as \texttt{Unit}, which behaves essentially like \texttt{void}. In Casanova, on the other hand, effectful computations are all typed in terms of \textit{coroutines} in order to clearly delimit their usage. For example, assignment has type:

\begin{mathpar}
\inferrule
{\Gamma \vdash t_1:\texttt{var<T>},t_2:\texttt{T}}
{\Gamma \vdash t_1:=t_2:\texttt{Co<Unit>}}
\end{mathpar}

\noindent{where} we used the \texttt{Co} abbreviation for \texttt{Coroutine}. Reading a variable, on the other hand, does not cause any side-effects and so it is not typed in terms of coroutines:

\begin{mathpar}
\inferrule
{\Gamma \vdash t:\texttt{Var<T>}}
{\Gamma \vdash !t:\texttt{T}}
\end{mathpar}

The main point of coroutines is that they are the only place where the developer can put all the side-effects he needs, in a "safe place" where those side effects will not interact in undesired ways between each other. Containing side-effects enables us to safely perform optimizations that would otherwise be impossible because side-effects would break the invariants needed for such optimizations. Coroutines may only be invoked by other coroutines, excluding the \texttt{main} coroutine and the \texttt{input} coroutines which are run as appropriate by the Casanova runtime. Coroutines prevent a developer from performing dangerous mutation operations from inside the body of rules, and they force all imperative operations to happen either inside the main script or inside the input scripts (or else there will be a compiler error!).

Coroutines are not just ways to encapsulate stateful computations: coroutines are also, and mainly, a tool for controlling how the (possibly imperative) operations of a sequential process are mixed with the game loop. The simplest coroutine possible is the one which finishes its job by invoking \texttt{return} on its result. We sequentialize coroutines together with the \texttt{let!} and \texttt{do!} operators. Coroutines may also be combined together according to a series of operators which mirror the fact that coroutines can be seen as threads that can: be run in parallel together until they both finish ($\wedge$); be run concurrently until the first terminates, discarding the other ($\vee$); be run in cascade but only when the first terminates with a certain positive result ($\Rightarrow$); be repeated indefinitely ($\Uparrow$). A coroutine may also wait for a certain amount of seconds, or it may wait for a single tick of the simulation (also known as \textit{yield}-ing).
The typing rules that govern how coroutines may be combined together are listed in Figure \ref{fig:coroutine typing rules}.

\begin{figure}
\begin{mathpar}
\inferrule
{\Gamma \vdash x:\texttt{T}}
{\Gamma \vdash \texttt{return } x:\texttt{Co<T>}}

\inferrule
{\Gamma \vdash t1:\texttt{Co<U>} \Gamma,x:\texttt{U} \vdash t2:\texttt{Co<V>}}
{\Gamma \vdash \texttt{let! } x \texttt{=} t1 \texttt{ in } t2:\texttt{Co<V>}}

\inferrule
{\Gamma \vdash t1:\texttt{Co<Unit>},t2:\texttt{Co<V>}}
{\Gamma \vdash \texttt{do! } t1\texttt{; }t2:\texttt{Co<V>}}

\inferrule
{}
{\vdash \texttt{yield}:\texttt{Co<Unit>}}

\inferrule
{\Gamma \vdash t:\texttt{float<s>}}
{\Gamma \vdash \texttt{wait }t:\texttt{Co<Unit>}}

\inferrule
{\Gamma \vdash t_1:\texttt{Co<U>},t_2:\texttt{Co<V>}}
{\Gamma \vdash t_1\texttt{ \&\& }t_2:\texttt{Co<U*V>}}

\inferrule
{\Gamma \vdash t_1:\texttt{Co<U>},t_2:\texttt{Co<V>}}
{\Gamma \vdash t_1 \texttt{ || } t_2:\texttt{Co<Either<U,V>>}}

\inferrule
{\Gamma \vdash t_1:\texttt{Co<bool>},t_2:\texttt{Co<V>}}
{\Gamma \vdash t_1 \texttt{ => } t_2:\texttt{Co<V>}}

\inferrule
{\Gamma \vdash t_1:\texttt{Co<Option<U>>},t_2:\texttt{U}\rightarrow\texttt{Co<V>}}
{\Gamma \vdash t_1\texttt{ => }t_2:\texttt{Co<V>}}

\inferrule
{\Gamma \vdash t:\texttt{Co<Unit>}}
{\Gamma \vdash \texttt{repeat }t:\texttt{Co<Unit>}}

\inferrule
{\Gamma \vdash t_1:\texttt{Var<T>},t_2:\texttt{T}}
{\Gamma \vdash t_1:=t_2:\texttt{Co<Unit>}}
\end{mathpar}
\caption{Coroutine typing rules}
\label{fig:coroutine typing rules}
\end{figure}


\begin{comment}
[[[THIS SHOULD NOT APPEAR]]]

Designing a type system allows for more than simply defining how the various syntactic pieces fit correctly together in order to forbid meaningless programs. Type systems may also be used to validate more advanced correctness properties, such as correct use of system resources, security, and more. In our case, we wish to define an (optional) extension to the language that allows the language to reject all those scripts which may not terminate correctly. This extension is defined as optional for two reasons: the first is that it may turn out to be too restrictive, that is it may reject programs that in reality do terminate, and so the language must not rely on it and it must be switchable off; the second is that this extension to the type system does not in any way modify the way data is represented at run-time, and so it is very easy to erase the data used by this extension after program compilation.

This extension is built in order to forbid a certain scenario: that of a coroutine which loops forever without ever yielding. This means that we need to represent additional information inside the type of a coroutine, and that this information will trace whether or not a coroutine is a risky one (loops without yielding) or not. 

[[[DO JUST TWO COMBINATORS SUFFICE? WOULD IT NOT BE CLEANER WITH THREE?]]]

We start by defining two empty types, \texttt{NT} and \texttt{T}, which respectively represent scripts that may not terminate in a single tick of the update function and scripts that certainly terminate in a single tick of the update function. This means that \texttt{Co<T,U>} will certainly \texttt{yield} at some point, even if it may take a long time in doing so, while \texttt{Co<NT,U>} may keep performing computations indefinitely, thereby blocking the game loop. Notice that we are not tracking termination of the script, so we do not really know if a script will return a final value; we are only interested in coroutines that suspend themselves, even if they never return a result.

In the following we ignore the second parameter of coroutines and only focus on how the termination parameter is combined across different coroutines. So we will only write \texttt{Co<T>} or \texttt{Co<NT>}, and we will assume the previously seen typing rules for the other type parameters.

All the sequentialization or parallelization operators simply propagate uncertainty in termination, that is binding or running in parallel a coroutine that does not terminate with another that terminates will result in a coroutine that does not terminate:

\begin{lstlisting}
Bind:Co<NT> * Co<_> -> Co<NT>
Bind:Co<_> * Co<NT> -> Co<NT>
Bind:Co<T> * Co<T> -> Co<T>

yield:Co<T>
return:Co<T>

parallel:Co<NT> * Co<_> -> Co<NT>
parallel:Co<_> * Co<NT> -> Co<NT>
parallel:Co<T> * Co<T> -> Co<T>

concurrent:Co<NT> * Co<_> -> Co<NT>
concurrent :Co<_> * Co<NT> -> Co<NT>
concurrent :Co<T> * Co<T> -> Co<T>

guard:Co<T> -> Co<T>

repeat:Co<T> -> Co<T>
repeat:Co<NT> -> Co<NT>
\end{lstlisting}

The crux of the matter, on the other hand, lies in the typing rules for conditionals: conditionals, regardless of their condition, are assumed to not terminate if one of their branches does not; only if both branches certainly terminate do we allow them:

\begin{lstlisting}
if : bool -> Co<NT> -> Co<_> -> Co<NT>
if : bool -> Co<_> -> Co<NT> -> Co<NT>
if : bool -> Co<T> -> Co<T> -> Co<T>
\end{lstlisting}

Finally, we define how we may introduce a coroutine that does not terminate. This is actually simple: a coroutine that only contains a series of regular let-bindings and is followed by a \texttt{return} operation has type \texttt{Co<NT>}. The final result is that:

\begin{lstlisting}
repeat
  co{
    return ()
  }
\end{lstlisting}

will have type \texttt{Co<Unit, NT>}, while 

\begin{lstlisting}
repeat
  co{
    do! yield
    return ()
  }
\end{lstlisting}

will have type \texttt{Co<Unit, T>}. The possible extension to the Casanova compiler would then reject all coroutines of type \texttt<NT>, which represent a liability since they would put the game at risk of staying locked forever into a single iteration of the game loop.

The reason why this extension will either be optional or will just generate warnings rather than unrecoverable errors is that acceptable code such as:

\begin{lstlisting}
if false then 
 repeat co{ return () }
else
 repeat yield
\end{lstlisting} 

would still be rejected by the compiler, which does not check the conditions on \texttt{if} statements and instead assumes that both branches may be executed. Since acceptable code may be ruled out by the compiler, we still wish to leave the final choice to the developer.
\end{comment}
