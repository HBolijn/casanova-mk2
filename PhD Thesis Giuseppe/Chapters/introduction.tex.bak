Video-games have seen a growing diffusion among users in the last decade \cite{CHAPTER_1_GROWING_DIFFUSION}. Games have recently reached (and surpassed) other major entertainment industries such as the movies and the music industries \cite{CHAPTER_1_MOVIES_AND_MUSIC}. This fact alone makes games worthy of study, because a better understanding of games would yield benefits to the many people who make or use games in their lives.

Games are not just aimed at entertainment though. There are opportunities to make use of games in \textit{serious} contexts. Such contexts may be industries like defense, education, scientific exploration, health care, emergency management, city planning, engineering, religion, and politics. This further motivates the interest of games from a research standpoint.

The use of (physical, not digital) games for serious purposes has been known for a long time. There are well-documented instances of the use of games for example in educational circles since the 1900s \cite{CHAPTER_1_EDUCATIONAL_GAMES_1900}. The diffusion of modern computers in the 1980s renewed the movement of educational games with the introduction of educational video-games \footnote{This broad genre of games is labeled \textit{Edutainment}, a portmanteau of \textit{education} and \textit{entertainment}}. Notable games used for the purpose were Oregon Trail, Math Blaster, and Number Munchers \cite{CHAPTER_1_OLD_EDUCATIONAL_VIDEOGAMES}. In 2002 the movement called \textit{serious games movement} was born from the Woodrow Wilson International Center for Scholars, which aimed at studying the use of games outside the educational sector. Among the main users and producers of such games is the United States Army, with notable titles such as America's Army and Full Spectrum Warrior that were also diffused among regular players who used them for entertainment purposes. Interestingly, military officers have been using non-digital war games in order to train strategic skills for a long time. One early example of such game is the 19th century Prussian military training game \textit{Kriegsspiel}.

The ease of adapting games to other activities beside entertainment is not difficult to explain. Games are, at their core, \textit{an activity among two or more independent decision-makers seeking to achieve their objectives in some limiting context} \cite{CHAPTER_1_DEFINITION_OF_GAME}. The game defined this way is very similar to a simulation of the way human beings experience reality, since humans are accustomed to making decisions in a limited context (time, physical, and social limitations being universal human experiences) in order to achieve some goal (survival, happiness, and reproduction being once again universal human goals). The definition of the actions allowed by the game and the objective to achieve determines whether or not the game is a serious one or not, and how amusing it can be playing it. For example, survival in daily life can be fun as long as it is challenging, fast paced, and the consequences of actions are exaggerated, as we can witness in the Sims games \cite{CHAPTER1_SIMS_GAMES}. The same setting, but with slower actions, limited consequences, and in real time could be far less interesting for a game. Survival in a challenging environment can either be fun or enlightening for the player, as long as he gets the right tools to overcome the challenge in some way.

Serious games have some strong issues to solve though. Edutainment games have continuously failed to prove profitable. The technological hurdles associated with making games put makers of serious games in the difficult position of risking a large investment for little chances of profit. This has led to the search for different purposes to which apply serious games \cite{CHAPTER_1_APPLICATIONS_OF_SERIOUS_GAMES}.

Similar problems are faced by indie-games \cite{CHAPTER_1_ISSUES_WITH_INDIE_GAMES}. Indie-games are those low-cost games (below the 10\$ mark, and sometimes even ad-based) often played in modern smart-phones and tablets \cite{CHAPTER_1_INDIE_GAMES_ON_SMARTPHONES_AND_TABLETS}. These games are full-fledged games from all points of view, but they are built with a smaller scope than major titles \cite{CHAPTER_1_INDIE_GAMES_SIZE}.

The costs associated with making games are indeed very high, no matter the games developed. Moreover, the costs for making a game are increasing as generations of hardware unlock new possibilities such as real-time multiplayer games, advanced graphics, advanced physics, bigger environments, smart opponents and characters, and so on. This increase in costs seems to be exponential in nature \cite{CHAPTER_1_EXPONENTIAL_COST_OF_GAMEDEV}. This is due to the ever more increased interactions between complex components of the game. For example, with few objects, simple physics, and a small set actions available to a character, it is relatively straightforward to build a simple but effective AI. As the game grows more complex, physics consequences must be considered by the characters, the number of actions available becomes bigger, etc. then building an AI which is just as effective as before becomes harder.

Smaller development efforts paradoxically encounter more difficulties than big studios. This happens because big studios have far more resources to throw at the problem, and thus can create huge and complex games with sheer brute-force. \textit{It is for this reason that our research will focus on indie and serious games rather than large games.}

The interest in game-development for both serious games and indie games has spurred the growth of substantial interest in research on principled design techniques and on cost-effective development technologies for game architectures. Our present endeavor makes a step along the directions of studying disciplined models for game development.

Among the biggest challenges that game developers encounter, not only do we find the quality and complexity of the simulation and its visual aspects; games need to run smoothly on common hardware, thus requiring specialized technical knowledge in the field of algorithmic optimizations. Multiplayer in games also presents difficulties: reliable synchronization across a network is challenging by itself, but the ability to do so in real-time is even harder. As an additional challenge, game-making comprises a (rather large) creative portion that is performed by designers \cite{CHAPTER_1_DESIGNERS_TOUCH_THE_GAME}, who rarely are well-versed in advanced computer programming: for this reason the architecture of a game must be flexible and easily modifiable so that designers can quickly build and test new iterations of game-play. 

We can state the general problem that we tackle in this work as follows: \textit{games offer a unique blend of complexity, optimization, and need for customization by non-programmers; this makes games costly to build and maintain, and it also makes it hard but desirable to simplify the process of game development.}

The process of game development that we aim at simplifying is one of the biggest focuses of this work. To do this, we reason on how games are usually created. Games are made by creating and reusing components which are called \textit{game engines} \cite{CHAPTER_1_GAME_ENGINES}. Game engines are large and powerful tools that are hard to maintain and modify incrementally \cite{CHAPTER_1_GAME_ENGINES}. Also, the changing landscape of gaming consoles and platforms forces the obsolescence of many such systems after a few years. For this reason, game developers tend to follow the cycle of building a game engine, and then use it as long as possible to release various games based on that engine (incrementally fixing its bugs and adjusting it slightly) \cite{CHAPTER_1_GAME_ENGINES_MUST_BE_REBUILT_OFTEN}. This process has the evident shortcomings that games based on the same engine tend to be very similar to each other; for example, subsequent games in the Halo series, such as Halo 3 and Halo ODST, or Halo Reach and Halo Anniversary, look and feel very similar to each other and "only" swap scenarios and stories. A less evident shortcoming is that, since building an engine is a costly and risky effort, engines tend to be similar to each other and to their previous incarnations. Game development is a risky enough endeavour already, and so engines are built only around proven game concepts and genres such as sports game, real-time-strategy game (RTS), role playing game (RPG), first-person-shooter (FPS), and so on.

The specific problem that we wish to solve then is that modern game development is done with game engines and traditional software engineering. The programming languages and techniques used for making games are intended for other purposes, namely representing and manipulating data that is transformed from some input into some output. Most computer programs are still related to the early models of computation \cite{CHAPTER_1_EARLY_MODELS_OF_COMPUTATION}, that is performing mathematical computations that require little to no user intervention. Interactivity is an aspect of computer programming that has emerged only in recent times. We argue that \textit{using languages and abstractions designed for the specific purpose of building games and interactive simulations, rather than using general purpose ones, can reduce the difficulty and economical risks of making games}. We also argue that currently available tools and techniques have shaped an industry that is excessively risk averse and which cannot easily create games that are truly innovative in terms of gameplay, AI, story-telling, etc.

A proper language for making games should be: \textit{(i)} simple; \textit{(ii)} useful across all game development tasks; \textit{(iii)} general in that it does not constrain the kind of games that are built with it; and \textit{(iv)} fully composable, that is all reasonable combinations of its features should be possible.

The research questions that we propose to answer in this thesis are:

\input{Chapters/research_questions}

%Jens Palsberg, Purdue University
\section{Motivating a new programming language}
Creating a programming language may be seen as a fruitless endeavor. Specifically, there are many programming languages that have been created as part of research efforts. Very rarely such languages have seen widespread adoption, and virtually all of them have been confined to research labs.

It is very important to notice, though, that the purpose of such research has never been that of creating industrial-grade tools that are used by many. Rather, the purpose of programming languages research is to shed new light on the best practices by exploring \textit{unknown possibilities} \cite{CHAPTER_1_PL_RESEARCH}. Indeed, many defunct research languages actually paved the way for innovations in future languages \cite{CHAPTER_1_PL_INFLUENCE_ON_PL}, software engineering \cite{CHAPTER_1_PL_INFLUENCE_ON_SWENG}, and even tools and systems that are now wide-spread \cite{CHAPTER_1_PL_INFLUENCE_ON_CURRENT_LANGUAGES}.
Sometimes there have even been decades of difference in terms of time between invention and adoption. One need only realize that research in programming languages has yielded benefits that range from sub-routines \cite{CHAPTER_1_PL_SUBROUTINES}, to data structures \cite{CHAPTER_1_PL_DATASTRUCTURES}, to objects \cite{CHAPTER_1_PL_OBJECTS}, to delegates and callbacks \cite{CHAPTER_1_PL_HOF}, to generics \cite{CHAPTER_1_PL_INFLUENCE_ON_PL}, to compile-time meta-programming \cite{CHAPTER_1_PL_GENERIC_PROGRAMMING}, to garbage collection \cite{CHAPTER_1_PL_GARBAGE_COLLECTION}, and so on.

The motivation for choosing to create a programming language rather than trying to engineer (yet another) game development system, is also grounded in the observation that there exist many game development systems. From top-of-the-line game engines such as ID's engines, CryTek, Aurora, etc. to simpler tools aimed at hobbyist or indie developers such as Unity, GameMaker, XNA, and others, most existing systems either fall short in generality (it is rare that an FPS engine works well for other genres, such as RTSes, and vice-versa), or they fall short in expressive power (there are few games made in GameMaker that are sufficiently advanced to be compared to commercial AAA \footnote{AAA games are all those major games developed by large studios with multi-million, multi-year efforts of tens of people} or even AA \footnote{indie-games built with a considerable budget of tens or even hundreds of thousands of dollars and a many-months-long development cycle} games). 

As game development tools and systems are a heavily explored field, it is a possible source of novel insight to study how the problem of game development can be tackled by language design.

In general, building a programming language offers relevant advantages over designing a system. Ever since the dawn of computer science, programming languages have flourished. Despite Church and Turing's insights that all programming languages are born equal, new programming languages keep on being invented, each with its own strengths and weaknesses. We observe that languages are, primarily: \textit{(i)} syntactic abstraction mechanisms that reduce repetitive code; \textit{(ii)} thought shapers that induce a paradigm shift in how one should structure software; \textit{(iii)} simplifiers that boil down an existing paradigm to just its essential parts, often to increase understanding and insight; \textit{(iv)} law enforcers that make sure important invariants hold, to increase correctness, performance, or other properties. 

We now discuss how a programming language affects the \textit{(i)} flexibility, \textit{(ii)}  correctness, and \textit{(iii)} efficiency of the programs written in it. We describe why and how each of these three aspects is important for games and briefly note the relevance of each item with respect to game-development. We also explain how game development systems and languages fare in that regard.

\subsection{Flexibility}
Software is flexible when it is \textit{easy to understand, modify, and extend}. This is achieved through structuring the program well, but a programming language can help with the structuring.

Games are modified and tuned up to the very end of their development cycle, and sometimes even beyond \cite{CHAPTER_1_PATCHING_CYCLES}. This means that flexible architectures for making games are of importance for game developers.

Game development systems are usually designed with a series of predefined scenarios in mind, and depending on the system it may well be impossible to push it beyond its originally intended boundaries, even if it is sometimes needed. This makes such systems not truly flexible.

Flexibility depends on two main aspects which we describe in the following: \textit{(i)} abstraction \cite{CHAPTER_1_PL_INFLUENCE_ON_PL}, which allows to reuse code; and \textit{(ii)} code management \cite{CHAPTER_1_CODE_MANAGEMENT}, which allows to split code into separate and independent units.

\subsubsection{Abstraction}
The ability to create hierarchies of libraries makes it possible for a developer to capitalize on the work done by others before him. Programming languages allow the definition of \textit{reusable units}: procedures and functions allow avoiding duplicating code, data abstraction allows to reuse "similar" but otherwise different data-types in the same context without rewriting the same operation many times, and entire modules can be abstracted with design patterns.

Games feature huge code bases \cite{CHAPTER_1_SIZE_OF_GAMES} that we argue could be greatly reduced in size if some forms of abstraction were used to avoid re-writing huge similar parts. Game engines are a relevant example of this process in action.

Abstraction is impossible (or much harder to achieve) with systems where the user only has a GUI to perform actions. This happens because even though action sequences can be recorded, it is hard to make the recorded sequence \textit{parametric} so that with a simple change in some parameter then we obtain a different (but similar) sequence of actions.

\subsubsection{Code Management}
The larger a project, the more complex it will be to manage and to handle its various tasks and its state space. To manage this complexity a programmer splits the project into \textit{separate and isolated tasks and components}, for example by using modules and libraries \cite{CHAPTER_1_CODE_MANAGEMENT}. Certain languages, such as ML, even make it possible to abstract the use of modules; other languages that support object-orientation with polymorphism partially enable this through the use of interfaces that represent abstract modules. These techniques blur the line between code management and abstraction, which often are strongly linked together.

Code management is of particular importance in games. Games are very large software projects where teams of multiple people work concurrently on the same code base, and so clearly splitting the code in various modules that are loosely coupled together may reduce inter-dependencies and the difficulties associated with integrating changes across different modules.

Game development systems offer a partial form of code (and resource) management. Resources and scripts in a game engine are often separated in independent modules, and which are subsequently linked from the hierarchical structure that represents the game world.

\subsection{Correctness}
Software is always supposed to achieve a certain task under certain \textit{requirements of correctness}. Programming languages can help establish certain degrees of correctness by offering ways to specify and check important properties \cite{CHAPTER_1_PL_STATIC_ANALYSIS}.

In game development, correctness constraints could be specified so that, for example, the language ensures the correct dimensional analysis for physics quantities, the correct generation of state machines, etc.

Systems that are well-designed and well-tested often offer strong correctness guarantees, since they force the user to interact with the project only according to a predefined set of rules and by sanitizing his input so that only safe operations are performed.

Correctness depends on: \textit{(i)} memory safety to ensure that the program does not manipulate nonsensical values; \textit{(ii)} concurrency control to arbitrate accesses to shared resources; and \textit{(iii)} bug finding to define how testing may be performed and what assurances it gives to developers.

\subsubsection{Memory Safety}
Accessing unallocated memory, jumping to data-addresses, or in general \textit{carelessly manipulating memory addresses} can result in catastrophic, hard to debug errors. By using a static type-system that ensures that all data manipulated and passed to procedures is of the correct type ensures that memory accesses are always properly aligned \cite{CHAPTER_1_PL_TYPE_SYSTEMS_AND_MEMORY_ALIGNMENT}. Static type systems have no run-time overhead, that is after the program is type-checked at compile time the produced assembly code has no trace of the types used during compilation. Garbage collection also helps ensuring such safety \cite{CHAPTER_1_PL_GARBAGE_COLLECTION}.

Games manage large numbers of objects with unpredictable, highly dynamic lifetimes. This makes a reliable memory system useful because thanks to it the developer does not have to manually track the life-cycle of an entity to deallocate its representation by hand; such a technique risks to maintain references to a deallocated entity, or to not deallocate some entities that are not references anymore and which thus occupy memory for no reason.

Game systems achieve correctness through extensive testing \cite{CHAPTER_1_PATCHING_CYCLES}, and often make use of unsafe memory manipulation techniques \cite{CHAPTER_1_POINTER_ARITHMETICS_IN_GAME}. As such, they only offer empirical guarantees (through extensive testing \cite{CHAPTER_1_TESTING_DOES_NOT_WORK}) about the memory safety of games, and moreover they never exclude the possibility of memory leaks or similar mishaps since running the game may encounter conditions which did not occur during testing.

\subsubsection{Concurrency Control}
Languages often operate on shared resources accessed by \textit{concurrent processes}.

This is particularly relevant in a game, where many entities operate concurrently on the game world \cite{CHAPTER_1_GAMES_ARE_CONCURRENT}, and they must be synchronized in order to guarantee that the logical invariants of the game are respected.

A system can have a predefined, monolithic system for managing concurrency, while a language can define a paradigm that (to various degrees) arbitrates access to shared resources \cite{CHAPTER_1_PL_AND_RESOURCE_SHARING}.

\subsubsection{Bug finding}
Most software development is spent on \textit{testing}, rather than writing code \cite{CHAPTER_1_TESTING_MORE_THAN_WRITING}. By forcing certain properties on a program (or on parts of it), such as the absence of side-effects in functions, it becomes easier to test a program in a bottom-up fashion \cite{CHAPTER_1_TESTING_WITHOUT_SIDE_EFFECTS}. The absence of side-effects allows testing smaller pieces of the program in isolation first, and then testing their composition until most of the program is tested properly. On the contrary, programs where many functions read and write on lots of global values requires testing one's program against all combinations of function call sequences and initial values of the shared state: such a task may be nigh impossible.

The number of possible configurations in a game world is very large, given that many entities in the game can move, change their internal statistics, etc. The very large space that must be tested in games allows them to benefit significantly from a bottom-up testing strategy in the absence of side effects, since this would reduce the number of tests to be performed while being assured that composing the smaller parts of the game that have been tested preserves correctness.

Game systems usually allow the definition and concurrent manipulation of global game variables, and in general suffer the issue where the insertion in the game of an apparently innocent and (locally) correct procedure may suddenly break something else (which may even appear to be unrelated) \cite{CHAPTER_1_TESTING_WITH_SIDE_EFFECTS}.

\subsection{Efficiency}
Software efficiency is measured by the amount of resources it uses to accomplish its task. A variety of resources can be considered, from time and space to network bandwidth, power, and databases. When \textit{resources are constrained}, a language' constructs and compiler can be made aware of these resources and even of the possible optimization strategies \cite{CHAPTER_1_COMPILER_OPTIMIZATIONS}. A language can make it easier to express efficient algorithms by supporting efficient data structure declaration and traversal; for example, we can observe that building a balanced binary tree is simpler \footnote{Or at least much closer to its definition in mathematical notation, and relatively far from the technical details of a computer.} to do with union types \ref{chap:fsharp} in the style of ML rather than with C structures and pointers. A compiler or interpreter such as those used for SQL can also heavily elaborate the input program and insert the appropriate optimizations so that the user does not have to do so by hand (and sometimes without even being aware of them) and still get an efficient program \cite{CHAPTER_1_SQL_OPTIMIZATIONS}.

In game development CPU time is a crucial resource, since if the game runs slowly then the gaming experience will fail to be immersive and the game will have missed its mark completely. A language that is aware of the needs of a game can help by ensuring that any code written for the game will be optimized automatically, for example running certain portions of the game logic in parallel or optimizing Cartesian products with the use of spatial partitioning indices.

Game development systems usually provide a series of commonly used underlying services such as rendering, input management, and physics, which are highly optimized; they then rely on the game developer to not write code that will slow down the game excessively.


\section{Structure of This Work}
In this work we explore the creation and implementation of a novel language for making games, Casanova. Casanova generalizes our knowledge of the common patterns and techniques for making game into a programming language which syntax and semantics are centered around game development activities. Expressing many aspects of game development can be shorter and clearer in Casanova than it can be in traditional, general purpose programming languages, since Casanova already has many relevant primitives built-in. 

Casanova is also the name of a .Net framework for game development that we have built around the F\# language. Using an existing language and its tool-chain yields important benefits such as a debugger, a profiler, code-completion, and more. The framework is a limited version of the language, since using an existing language allows for less freedom when adding syntactic constructs; this means that while the framework is more usable in practice, it also loses some of the theoretical advantages that the language could offer.

We start by describing the requirements that many modern real-time games share in Chapter \ref{chap:game_requirements}. We then overview the existing systems for making games in Chapter \ref{chap:available_systems}. 

We move on to the design, semantics, and implementation of Casanova in Chapters \ref{chap:design}, \ref{chap:semantics}, and \ref{chap:implementation}.

We evaluate the feasibility of Casanova by studying how easy it is to make games in it in Chapter \ref{chap:making_games}, and by comparing it with existing languages and systems for making games in Chapter \ref{chap:evaluation}.

We conclude with a discussion of the limitations and future work in Chapters \ref{chap:discussion} and \ref{chap:conclusions}.

In the Appendices \ref{chap:menu_system} and \ref{chap:networking} we describe some of the features of Casanova that are "almost there": a menu system and automated networking support for multi-player games. We also describe how a goal-oriented planning AI could act as a general-purpose AI system for Casanova in Appendix \ref{chap:goap}. In Appendix \ref{chap:casanova_and_dbs} we discuss how data-bases offered an interesting set of inspirations that ultimately shaped up Casanova in its current form. In appendix \ref{chap:casanova_in_haskell_and_cpp} we sketch how Casanova could be implemented with different, well-known languages such as Haskell and C++. In the final appendices, \ref{chap:fsharp}, and \ref{chap:monads}, we offer a brief introduction to F\#, the language we used to build the Casanova framework, and monads, an important tool from Category Theory and functional programming that we heavily used in the construction of Casanova.
